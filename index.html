<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Earth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            letter-spacing: 4px;
            pointer-events: none;
            transition: opacity 1s ease;
            opacity: 1;
            z-index: 10;
        }
        #error-msg {
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-top: 10px;
            letter-spacing: 1px;
        }
        .status-text {
            font-weight: bold;
            text-transform: uppercase;
        }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Unified Overlay for Loading and Transitions -->
    <div id="overlay">
        <div id="status-msg" class="status-text">LOADING...</div>
        <div id="error-msg"></div>
    </div>
    
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const config = {
            rotationSpeed: 0.0, 
            earthRadius: 5,
            displacementScale: 0.525, 
            dayNightCycleDuration: 24, 
            // Navigation Thresholds
            zoomInThreshold: 5.0,   // Triggers surface view
            zoomOutThreshold: 50.0   // Triggers command center
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 16);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false; 
        
        // Ranges: 10 to 40
        controls.minDistance = 5;    
        controls.maxDistance = 50;   
        
        controls.autoRotate = false;
        controls.zoomSpeed = 1.5;
        controls.rotateSpeed = 0.5;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.02);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(15, 5, 10);
        scene.add(sunLight);
        
        const rimLight = new THREE.DirectionalLight(0xccccff, 0.1);
        rimLight.position.set(-10, 0, -10);
        scene.add(rimLight);

        // --- Loading Manager ---
        const overlay = document.getElementById('overlay');
        const statusMsg = document.getElementById('status-msg');
        const errorEl = document.getElementById('error-msg');
        
        const manager = new THREE.LoadingManager();
        manager.onLoad = function ( ) {
            statusMsg.innerText = "SYSTEMS ONLINE";
            setTimeout(() => {
                overlay.style.opacity = 0;
            }, 500);
        };
        manager.onError = function ( url ) {
            console.log( 'Error loading ' + url );
            errorEl.innerText = "ASSET LOAD ERROR";
        };

        const textureLoader = new THREE.TextureLoader(manager);
        
        // --- TEXTURES ---
        const textureURLs = {
            color: 'https://sbcode.net/topoearth/downloads/worldColour.5400x2700.jpg',
            height: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/World_elevation_map.png/2560px-World_elevation_map.png',
            specular: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg',
            lights: 'https://upload.wikimedia.org/wikipedia/commons/b/ba/The_earth_at_night.jpg',
            galaxy: 'https://upload.wikimedia.org/wikipedia/commons/6/60/ESO_-_Milky_Way.jpg',
        };

        // --- Earth Material (Phong) ---
        const earthGeometry = new THREE.SphereGeometry(config.earthRadius, 512, 256); 
        
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: textureLoader.load(textureURLs.color),
            displacementMap: textureLoader.load(textureURLs.height),
            displacementScale: config.displacementScale,
            displacementBias: -0.15, 
            bumpMap: textureLoader.load(textureURLs.height),
            bumpScale: 0.2, 
            specularMap: textureLoader.load(textureURLs.specular),
            specular: new THREE.Color(0x222222), 
            shininess: 25, 
            emissiveMap: textureLoader.load(textureURLs.lights),
            emissive: new THREE.Color(0xffcc33), 
            emissiveIntensity: 1, 
        });

        // Inject Custom Shader Logic (Night Lights)
        earthMaterial.onBeforeCompile = function(shader) {
            shader.uniforms.sunDirView = { value: new THREE.Vector3(0, 0, 1) };
            shader.fragmentShader = 'uniform vec3 sunDirView;\n' + shader.fragmentShader;
            shader.fragmentShader = shader.fragmentShader.replace(
                '#include <emissivemap_fragment>',
                `
                #ifdef USE_EMISSIVEMAP
                    vec4 emissiveColor = texture2D( emissiveMap, vMapUv );
                    vec3 normNormal = normalize(vNormal);
                    vec3 normSunDir = normalize(sunDirView);
                    float sunDot = dot(normNormal, normSunDir);
                    float nightMask = 1.0 - smoothstep(-0.2, 0.1, sunDot);
                    vec3 rawLights = emissiveColor.rgb;
                    float threshold = 0.25; 
                    vec3 clippedLights = max(vec3(0.0), rawLights - threshold) * (1.0 / (1.0 - threshold));
                    vec3 finalLights = clippedLights * emissive;
                    totalEmissiveRadiance = finalLights * nightMask * 6.0; 
                #endif
                `
            );
            earthMaterial.userData.shader = shader;
        };

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.rotation.z = 23.4 * Math.PI / 180; 
        earth.rotation.y = -1.5; 
        scene.add(earth);

        // --- Background Stars ---
        const starGeometry = new THREE.SphereGeometry(90, 64, 64);
        const starMaterial = new THREE.ShaderMaterial({
            uniforms: {
                galaxyTexture: { value: textureLoader.load(textureURLs.galaxy) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D galaxyTexture;
                varying vec2 vUv;
                void main() {
                    vec4 texColor = texture2D(galaxyTexture, vUv);
                    vec3 color = texColor.rgb;
                    color = pow(color, vec3(3.0));
                    color = color * 1.0;
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const starField = new THREE.Mesh(starGeometry, starMaterial);
        scene.add(starField);

        // --- Helpers ---
        const clock = new THREE.Clock();
        let sunAngle = 0;
        let isRedirecting = false;

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            controls.update();

            // --- NAVIGATION LOGIC ---
            if (!isRedirecting) {
                const distance = camera.position.distanceTo(controls.target);

                // 1. Zoom In -> Surface
                if (distance < config.zoomInThreshold) {
                    isRedirecting = true;
                    statusMsg.innerText = "Ready for landing";
                    overlay.style.opacity = 1; // Fade to black
                    setTimeout(() => {
                        window.location.href = 'home.html';
                    }, 1200);
                }
                
                // 2. Zoom Out -> Command Center
                else if (distance > config.zoomOutThreshold) {
                    isRedirecting = true;
                    statusMsg.innerText = "Ready for takeoff";
                    overlay.style.opacity = 1; // Fade to black
                    setTimeout(() => {
                        window.location.href = 'home.html';
                    }, 1200);
                }
            }

            // Animation
            starField.rotation.y += 0.0005;
            const sunSpeed = (2 * Math.PI) / config.dayNightCycleDuration * delta;
            sunAngle += sunSpeed;
            const sunDistance = 20;
            sunLight.position.x = Math.cos(sunAngle) * sunDistance;
            sunLight.position.z = Math.sin(sunAngle) * sunDistance;

            if (earthMaterial.userData.shader) {
                const sunDirWorld = new THREE.Vector3().copy(sunLight.position).normalize();
                const sunDirView = sunDirWorld.transformDirection(camera.matrixWorldInverse);
                earthMaterial.userData.shader.uniforms.sunDirView.value.copy(sunDirView);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>

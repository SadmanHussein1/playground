<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Earth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s ease;
            text-align: center;
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 8px;
        }
        #error-msg {
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-top: 10px;
        }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        LOADING UNIVERSE...
        <div id="error-msg"></div>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const config = {
            rotationSpeed: 0.5,
            earthRadius: 5,
            // Scale: How high/deep the features are
            displacementScale: 0.525, 
            dayNightCycleDuration: 48, 
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 16);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false; 
        controls.minDistance = 7.5;   
        controls.maxDistance = 50;  
        controls.autoRotate = true;
        controls.autoRotateSpeed = config.rotationSpeed;
        controls.zoomSpeed = 2.0;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.02);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(15, 5, 10);
        scene.add(sunLight);
        
        const rimLight = new THREE.DirectionalLight(0xccccff, 0.1);
        rimLight.position.set(-10, 0, -10);
        scene.add(rimLight);

        // --- Loading Manager ---
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error-msg');
        
        const manager = new THREE.LoadingManager();
        manager.onLoad = function ( ) {
            loadingEl.style.opacity = 0;
            setTimeout(() => loadingEl.remove(), 1000);
        };
        manager.onError = function ( url ) {
            console.log( 'Error loading ' + url );
            errorEl.innerText = "Error loading assets.";
        };

        const textureLoader = new THREE.TextureLoader(manager);
        
        // --- TEXTURES ---
        const textureURLs = {
            // High-Res Color Map (User Provided)
            color: 'https://sbcode.net/topoearth/downloads/worldColour.5400x2700.jpg',
            
            // DEDICATED HEIGHT MAP: Grayscale (White=High, Black=Deep)
            height: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/World_elevation_map.png/2560px-World_elevation_map.png',
            
            specular: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg',
            lights: 'https://upload.wikimedia.org/wikipedia/commons/b/ba/The_earth_at_night.jpg',
            // Galaxy / Stars Background - Using the ESO image but scaled for performance
            galaxy: 'https://upload.wikimedia.org/wikipedia/commons/6/60/ESO_-_Milky_Way.jpg',
        };

        // --- Earth Material (Phong) ---
        const earthGeometry = new THREE.SphereGeometry(config.earthRadius, 512, 256); 
        
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: textureLoader.load(textureURLs.color),
            
            // DISPLACEMENT
            displacementMap: textureLoader.load(textureURLs.height),
            displacementScale: config.displacementScale,
            displacementBias: -0.15, 
            
            // BUMP
            bumpMap: textureLoader.load(textureURLs.height),
            bumpScale: 0.2, 
            
            // SPECULAR (Reflections)
            specularMap: textureLoader.load(textureURLs.specular),
            specular: new THREE.Color(0x222222), 
            shininess: 25, 
            
            emissiveMap: textureLoader.load(textureURLs.lights),
            emissive: new THREE.Color(0xffcc33), 
            emissiveIntensity: 1, 
        });

        // Inject Custom Shader Logic (Night Lights)
        earthMaterial.onBeforeCompile = function(shader) {
            shader.uniforms.sunDirView = { value: new THREE.Vector3(0, 0, 1) };
            
            shader.fragmentShader = 'uniform vec3 sunDirView;\n' + shader.fragmentShader;

            shader.fragmentShader = shader.fragmentShader.replace(
                '#include <emissivemap_fragment>',
                `
                #ifdef USE_EMISSIVEMAP
                    vec4 emissiveColor = texture2D( emissiveMap, vMapUv );
                    
                    vec3 normNormal = normalize(vNormal);
                    vec3 normSunDir = normalize(sunDirView);
                    
                    float sunDot = dot(normNormal, normSunDir);
                    
                    // Twilight mask
                    float nightMask = 1.0 - smoothstep(-0.2, 0.1, sunDot);
                    
                    // --- RAW TEXTURE PROCESSING ---
                    vec3 rawLights = emissiveColor.rgb;
                    
                    // Thresholding (Anti-Haze)
                    float threshold = 0.25; 
                    vec3 clippedLights = max(vec3(0.0), rawLights - threshold) * (1.0 / (1.0 - threshold));
                    
                    // Apply Amber Tint
                    vec3 finalLights = clippedLights * emissive;
                    
                    // Output with intensity boost
                    totalEmissiveRadiance = finalLights * nightMask * 6.0; 
                #endif
                `
            );
            
            earthMaterial.userData.shader = shader;
        };

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // --- Background Stars (Universe) ---
        // Using a Custom Shader Material to control brightness and density
        const starGeometry = new THREE.SphereGeometry(90, 64, 64);
        
        const starMaterial = new THREE.ShaderMaterial({
            uniforms: {
                galaxyTexture: { value: textureLoader.load(textureURLs.galaxy) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D galaxyTexture;
                varying vec2 vUv;
                void main() {
                    vec4 texColor = texture2D(galaxyTexture, vUv);
                    vec3 color = texColor.rgb;
                    
                    // 1. CRUSH: Raising the power (gamma) hides faint stars and noise
                    // Higher number = fewer stars visible
                    color = pow(color, vec3(3.0));
                    
                    // 2. DARKEN: Scale down overall brightness
                    // Lower number = darker universe
                    color = color * 1.0;
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.BackSide
        });

        const starField = new THREE.Mesh(starGeometry, starMaterial);
        scene.add(starField);

        // --- Helpers ---
        const clock = new THREE.Clock();

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();

            controls.update();

            // Earth Rotation
            const rotationStep = (1 * Math.PI) / config.dayNightCycleDuration * delta;
            earth.rotation.y += rotationStep;

            // Update Sun Direction in Shader
            if (earthMaterial.userData.shader) {
                const sunDirWorld = new THREE.Vector3().copy(sunLight.position).normalize();
                const sunDirView = sunDirWorld.transformDirection(camera.matrixWorldInverse);
                earthMaterial.userData.shader.uniforms.sunDirView.value.copy(sunDirView);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI</title>
    <!-- Import Chess.js for logic validation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        :root {
            --bg-color: #000000; /* Pure Black as requested */
            --board-border: #333;
            --white-square: #E8EDF9; /* Very light cool white */
            --black-square: #7D8DA5; /* Muted Steel Blue - lighter and softer */
            --highlight: rgba(255, 255, 0, 0.5);
            --text-color: #e2e2e2;
            --panel-bg: #1a1a1a;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent scrolling on mobile drag */
        }

        h1 { margin: 10px 0; font-size: 1.5rem; color: #aaa; }

        /* Game Container */
        .game-container {
            display: flex;
            flex-direction: row; /* Side by side on desktop */
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1000px;
            padding: 10px;
            box-sizing: border-box;
        }

        .main-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }

        /* Status Bar */
        #status {
            margin-bottom: 10px;
            font-weight: bold;
            height: 1.2em;
            color: #7D8DA5; /* Matches board blue */
            text-align: center;
        }

        /* Chess Board */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 100%;
            max-width: 80vh; /* Ensure it fits vertically */
            aspect-ratio: 1 / 1;
            border: 5px solid var(--board-border);
            user-select: none;
            -webkit-user-select: none;
            background-color: var(--board-border);
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Responsive font size */
            font-size: clamp(1.5rem, 6vw, 3.5rem); 
            cursor: pointer;
            position: relative;
            /* Ensure squares stay square */
            aspect-ratio: 1/1; 
        }

        /* Board Colors */
        .white-sq { background-color: var(--white-square); color: black; }
        .black-sq { background-color: var(--black-square); color: black; }

        /* Pieces (Unicode) */
        .piece {
            z-index: 2;
            transition: transform 0.1s;
            pointer-events: none; /* CRITICAL: Allows clicks to pass through to the square */
            line-height: 1;
            font-weight: normal;
        }
        
        /* Clean visibility */
        .piece.w { 
            color: #fff; 
            text-shadow: 0 0 2px #000, 0 1px 3px rgba(0,0,0,0.6); 
        }
        .piece.b { 
            color: #000; 
            text-shadow: 0 0 1px #fff; 
        }

        /* Highlights */
        .selected { background-color: rgba(255, 255, 50, 0.5) !important; } 
        .last-move { background-color: rgba(100, 200, 255, 0.4) !important; }
        
        .possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            z-index: 1;
        }

        /* Controls */
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background-color: #333;
            color: white;
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover { background-color: #444; }
        button:active { transform: translateY(1px); }

        /* Move History Panel */
        .history-panel {
            background-color: var(--panel-bg);
            border: 1px solid #333;
            border-radius: 8px;
            width: 200px;
            height: 400px; /* Match approximate board height */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: none;
        }

        .history-header {
            padding: 10px;
            background-color: #111;
            text-align: center;
            font-weight: bold;
            color: #aaa;
            border-bottom: 1px solid #333;
        }

        #move-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .move-row {
            display: flex;
            border-bottom: 1px solid #2a2a2a;
            padding: 2px 0;
        }
        .move-num { width: 30px; color: #555; }
        .move-white, .move-black { flex: 1; color: #ccc; }

        /* AI Thinking Indicator */
        .loader {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-bottom-color: transparent;
            border-radius: 50%;
            animation: rotation 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Layout for Mobile */
        @media (max-width: 800px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .history-panel {
                width: 100%;
                max-width: 80vh;
                height: 150px; /* Shorter on mobile */
            }
            #board {
                max-width: 95vw; /* Maximize width on mobile */
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <div class="main-column">
        <h1>♛ Chess vs AI <span class="loader" id="ai-loader"></span></h1>
        <div id="status">White to move</div>
        <div id="board"></div>
        
        <div class="controls">
            <button onclick="resetGame()">New Game</button>
            <button onclick="undoMove()">Undo</button>
            <button onclick="flipBoard()">Flip Board</button>
        </div>
    </div>

    <!-- Move History Sidebar -->
    <div class="history-panel">
        <div class="history-header">Moves Played</div>
        <div id="move-list">
            <!-- Moves will be populated here -->
        </div>
    </div>
</div>

<script>
    // --- Game State ---
    let game = new Chess();
    let boardEl = document.getElementById('board');
    let statusEl = document.getElementById('status');
    let moveListEl = document.getElementById('move-list');
    let loaderEl = document.getElementById('ai-loader');
    
    let selectedSquare = null;
    let orientation = 'white'; // 'white' or 'black'
    let isAIThinking = false;
    let aiColor = 'b'; // AI plays Black by default
    
    // --- AI Configuration ---
    const AI_DEPTH = 3; 
    
    // Position Evaluation Tables (Piece-Square Tables)
    const PST = {
        p: [
            [0,  0,  0,  0,  0,  0,  0,  0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5,  5, 10, 25, 25, 10,  5,  5],
            [0,  0,  0, 20, 20,  0,  0,  0],
            [5, -5,-10,  0,  0,-10, -5,  5],
            [5, 10, 10,-20,-20, 10, 10,  5],
            [0,  0,  0,  0,  0,  0,  0,  0]
        ],
        n: [
            [-50,-40,-30,-30,-30,-30,-40,-50],
            [-40,-20,  0,  0,  0,  0,-20,-40],
            [-30,  0, 10, 15, 15, 10,  0,-30],
            [-30,  5, 15, 20, 20, 15,  5,-30],
            [-30,  0, 15, 20, 20, 15,  0,-30],
            [-30,  5, 10, 15, 15, 10,  5,-30],
            [-40,-20,  0,  5,  5,  0,-20,-40],
            [-50,-40,-30,-30,-30,-30,-40,-50]
        ],
        b: [
            [-20,-10,-10,-10,-10,-10,-10,-20],
            [-10,  0,  0,  0,  0,  0,  0,-10],
            [-10,  0,  5, 10, 10,  5,  0,-10],
            [-10,  5,  5, 10, 10,  5,  5,-10],
            [-10,  0, 10, 10, 10, 10,  0,-10],
            [-10, 10, 10, 10, 10, 10, 10,-10],
            [-10,  5,  0,  0,  0,  0,  5,-10],
            [-20,-10,-10,-10,-10,-10,-10,-20]
        ],
        r: [
            [0,  0,  0,  0,  0,  0,  0,  0],
            [5, 10, 10, 10, 10, 10, 10,  5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [0,  0,  0,  5,  5,  0,  0,  0]
        ],
        q: [
            [-20,-10,-10, -5, -5,-10,-10,-20],
            [-10,  0,  0,  0,  0,  0,  0,-10],
            [-10,  0,  5,  5,  5,  5,  0,-10],
            [-5,   0,  5,  5,  5,  5,  0, -5],
            [0,    0,  5,  5,  5,  5,  0, -5],
            [-10,  5,  5,  5,  5,  5,  0,-10],
            [-10,  0,  5,  0,  0,  0,  0,-10],
            [-20,-10,-10, -5, -5,-10,-10,-20]
        ],
        k: [
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-20,-30,-30,-40,-40,-30,-30,-20],
            [-10,-20,-20,-20,-20,-20,-20,-10],
            [20, 20,  0,  0,  0,  0, 20, 20],
            [20, 30, 10,  0,  0, 10, 30, 20]
        ]
    };
    
    // Endgame King table
    const PST_K_ENDGAME = [
        [-50,-40,-30,-20,-20,-30,-40,-50],
        [-30,-20,-10,  0,  0,-10,-20,-30],
        [-30,-10, 20, 30, 30, 20,-10,-30],
        [-30,-10, 30, 40, 40, 30,-10,-30],
        [-30,-10, 30, 40, 40, 30,-10,-30],
        [-30,-10, 20, 30, 30, 20,-10,-30],
        [-30,-30,  0,  0,  0,  0,-30,-30],
        [-50,-30,-30,-30,-30,-30,-30,-50]
    ];

    const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

    // --- Initialization ---
    function init() {
        drawBoard();
        updateStatus();
    }

    // --- Drawing the Board ---
    function drawBoard() {
        boardEl.innerHTML = '';
        const board = game.board(); // 8x8 array

        // Handle board flipping
        const isFlipped = orientation === 'black';
        const rows = isFlipped ? [7,6,5,4,3,2,1,0].reverse() : [7,6,5,4,3,2,1,0];
        const cols = isFlipped ? [0,1,2,3,4,5,6,7].reverse() : [0,1,2,3,4,5,6,7];

        for (let r of rows) { // 0-7
            for (let c of cols) { // 0-7
                const squareName = String.fromCharCode(97 + c) + (8 - r);
                const squareDiv = document.createElement('div');
                squareDiv.className = 'square ' + ((r + c) % 2 === 0 ? 'white-sq' : 'black-sq');
                squareDiv.dataset.square = squareName;
                
                // Add click handler
                squareDiv.onclick = () => handleSquareClick(squareName);

                // Add Highlight classes
                if (selectedSquare === squareName) squareDiv.classList.add('selected');
                
                // Last Move Highlight
                const history = game.history({ verbose: true });
                if (history.length > 0) {
                    const lastMove = history[history.length - 1];
                    if (lastMove.from === squareName || lastMove.to === squareName) {
                        squareDiv.classList.add('last-move');
                    }
                }
                
                // King Check Highlight
                if (game.in_check()) {
                    const kingPos = findKing(game.turn());
                    if (squareName === kingPos) {
                        squareDiv.style.background = '#e74c3c'; // Red danger
                    }
                }

                // Render Piece
                const piece = board[r][c];
                if (piece) {
                    const pieceSpan = document.createElement('span');
                    pieceSpan.className = `piece ${piece.color}`;
                    pieceSpan.innerHTML = getPieceUnicode(piece.type, piece.color);
                    squareDiv.appendChild(pieceSpan);
                }
                
                // Show legal moves
                if (selectedSquare) {
                    const moves = game.moves({ square: selectedSquare, verbose: true });
                    if (moves.find(m => m.to === squareName)) {
                        squareDiv.classList.add('possible-move');
                    }
                }

                boardEl.appendChild(squareDiv);
            }
        }
    }

    function findKing(color) {
        const board = game.board();
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (board[r][c] && board[r][c].type === 'k' && board[r][c].color === color) {
                    return String.fromCharCode(97 + c) + (8 - r);
                }
            }
        }
        return null;
    }

    function getPieceUnicode(type, color) {
        const symbols = {
            w: { k: '♔', q: '♕', r: '♖', b: '♗', n: '♘', p: '♙' },
            b: { k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟' }
        };
        return symbols[color][type];
    }

    // --- Interaction ---
    function handleSquareClick(square) {
        if (isAIThinking || game.game_over()) return;

        // If clicking same square, deselect
        if (selectedSquare === square) {
            selectedSquare = null;
            drawBoard();
            return;
        }

        // Check if valid move from previously selected square
        if (selectedSquare) {
            const moves = game.moves({ square: selectedSquare, verbose: true });
            const move = moves.find(m => m.to === square);

            if (move) {
                game.move(move.san);
                selectedSquare = null;
                drawBoard();
                updateStatus();
                updateMoveHistory();
                
                // Trigger AI
                if (!game.game_over()) {
                    isAIThinking = true;
                    loaderEl.style.display = 'inline-block';
                    setTimeout(makeBestMove, 100);
                }
                return;
            }
        }

        // Select new square if it has our piece
        const piece = game.get(square);
        if (piece && piece.color === game.turn()) {
            selectedSquare = square;
            drawBoard();
        }
    }

    function updateStatus() {
        let status = '';
        let moveColor = game.turn() === 'b' ? 'Black' : 'White';

        if (game.in_checkmate()) {
            status = `Game over, ${moveColor} is in checkmate.`;
        } else if (game.in_draw()) {
            status = 'Game over, drawn position';
        } else {
            status = `${moveColor} to move`;
            if (game.in_check()) {
                status += ' (Check!)';
            }
        }
        statusEl.innerText = status;
    }

    function updateMoveHistory() {
        const history = game.history();
        moveListEl.innerHTML = '';
        
        for (let i = 0; i < history.length; i += 2) {
            const row = document.createElement('div');
            row.className = 'move-row';
            
            const num = document.createElement('div');
            num.className = 'move-num';
            num.innerText = (i / 2 + 1) + '.';
            
            const wMove = document.createElement('div');
            wMove.className = 'move-white';
            wMove.innerText = history[i];
            
            const bMove = document.createElement('div');
            bMove.className = 'move-black';
            bMove.innerText = history[i + 1] || '';
            
            row.appendChild(num);
            row.appendChild(wMove);
            row.appendChild(bMove);
            moveListEl.appendChild(row);
        }
        
        // Auto scroll to bottom
        moveListEl.scrollTop = moveListEl.scrollHeight;
    }

    // --- AI Engine ---
    function makeBestMove() {
        const moves = game.moves();
        if (moves.length === 0) return;

        let bestMove = null;
        let bestValue = -Infinity;
        
        const totalPieces = game.board().flat().filter(p => p !== null).length;
        const isEndgame = totalPieces < 10;

        moves.sort(() => Math.random() - 0.5);

        for (let i = 0; i < moves.length; i++) {
            game.move(moves[i]);
            let boardValue = minimax(AI_DEPTH - 1, -Infinity, Infinity, false, isEndgame);
            game.undo();
            
            if (boardValue > bestValue) {
                bestValue = boardValue;
                bestMove = moves[i];
            }
        }

        game.move(bestMove);
        isAIThinking = false;
        loaderEl.style.display = 'none';
        drawBoard();
        updateStatus();
        updateMoveHistory();
    }

    function minimax(depth, alpha, beta, isMaximizing, isEndgame) {
        if (depth === 0 || game.game_over()) {
            return evaluateBoard(isEndgame);
        }

        const moves = game.moves();

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (let i = 0; i < moves.length; i++) {
                game.move(moves[i]);
                let eval = minimax(depth - 1, alpha, beta, false, isEndgame);
                game.undo();
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) break; 
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let i = 0; i < moves.length; i++) {
                game.move(moves[i]);
                let eval = minimax(depth - 1, alpha, beta, true, isEndgame);
                game.undo();
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) break; 
            }
            return minEval;
        }
    }

    function evaluateBoard(isEndgame) {
        let totalEvaluation = 0;
        const board = game.board();

        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                const piece = board[i][j];
                if(piece) {
                    const value = getPieceValue(piece, i, j, isEndgame);
                    totalEvaluation += (piece.color === aiColor ? value : -value);
                }
            }
        }
        return totalEvaluation;
    }

    function getPieceValue(piece, r, c, isEndgame) {
        if (!piece) return 0;
        let value = PIECE_VALUES[piece.type];
        let pieceTable = PST[piece.type];
        if (piece.type === 'k' && isEndgame) {
            pieceTable = PST_K_ENDGAME;
        }

        let x = c;
        let y = r;

        if (piece.color === 'b') {
            y = 7 - r; 
            x = 7 - c;
        }

        value += pieceTable[y][x];
        return value;
    }

    // --- Controls ---
    function resetGame() {
        game.reset();
        selectedSquare = null;
        isAIThinking = false;
        drawBoard();
        updateStatus();
        updateMoveHistory();
    }

    function undoMove() {
        if (game.history().length < 2) return; 
        game.undo();
        game.undo();
        drawBoard();
        updateStatus();
        updateMoveHistory();
    }
    
    function flipBoard() {
        orientation = orientation === 'white' ? 'black' : 'white';
        drawBoard();
    }

    // Start
    init();

</script>
</body>
</html>

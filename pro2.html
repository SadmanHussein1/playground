<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 vs AI</title>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #f0f0f0;
            --board-color: #1e3a8a; /* Strong Blue */
            --slot-empty: #1a1a1a;
            --p1-color: #ef4444; /* Red */
            --p2-color: #eab308; /* Yellow */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            touch-action: manipulation;
        }

        h1 { margin-bottom: 10px; color: #ccc; font-size: 2rem; }

        .game-info {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        select, button {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            border: 1px solid #444;
            background-color: #333;
            color: white;
        }

        button:hover { background-color: #444; }
        
        #status {
            font-size: 1.2rem;
            font-weight: bold;
            height: 1.5em;
            color: var(--p1-color);
            margin-bottom: 15px;
        }

        /* The Board */
        .board {
            background-color: var(--board-color);
            padding: 15px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            max-width: 95vw;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
        }

        .column:hover .slot.empty {
            background-color: #2a2a2a; /* Hover effect */
        }

        .slot {
            width: 50px;
            height: 50px;
            background-color: var(--slot-empty);
            border-radius: 50%;
            transition: background-color 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
        }

        /* Pieces */
        .slot.p1 { background-color: var(--p1-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        .slot.p2 { background-color: var(--p2-color); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        
        /* Winning Line Highlight */
        .slot.win {
            animation: pulse 1s infinite;
            border: 3px solid white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Mobile adjustments */
        @media (max-width: 500px) {
            .slot { width: 40px; height: 40px; }
            .board { gap: 5px; padding: 10px; }
            .column { gap: 5px; }
        }

        .loader {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-bottom-color: transparent;
            border-radius: 50%;
            animation: rotation 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
            visibility: hidden;
        }
        .loader.active { visibility: visible; }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>

    <h1>Connect 4</h1>
    
    <div class="game-info">
        <select id="difficulty">
            <option value="1">Easy (Random)</option>
            <option value="3" selected>Medium</option>
            <option value="6">Hard (Thinker)</option>
        </select>
        <button onclick="resetGame()">New Game</button>
    </div>

    <div id="status">Your Turn (Red) <span class="loader" id="ai-loader"></span></div>

    <!-- Board Container -->
    <div class="board" id="board">
        <!-- Generated by JS -->
    </div>

<script>
    // --- Constants ---
    const ROWS = 6;
    const COLS = 7;
    const EMPTY = 0;
    const P1 = 1; // Player (Red)
    const P2 = 2; // AI (Yellow)
    
    // --- State ---
    let board = [];
    let currentPlayer = P1;
    let gameOver = false;
    let difficulty = 3;

    // --- DOM ---
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const difficultySel = document.getElementById('difficulty');
    const loaderEl = document.getElementById('ai-loader');

    // --- Initialization ---
    function init() {
        createBoardUI();
        resetGame();
        
        difficultySel.addEventListener('change', (e) => {
            difficulty = parseInt(e.target.value);
            resetGame();
        });
    }

    function createBoardUI() {
        boardEl.innerHTML = '';
        // Create columns for easier click handling
        for (let c = 0; c < COLS; c++) {
            const colDiv = document.createElement('div');
            colDiv.className = 'column';
            colDiv.dataset.col = c;
            colDiv.onclick = () => handleMove(c);
            
            for (let r = ROWS - 1; r >= 0; r--) {
                const slot = document.createElement('div');
                slot.className = 'slot empty';
                slot.id = `slot-${r}-${c}`;
                colDiv.appendChild(slot); // Visual order: Top to bottom
            }
            boardEl.appendChild(colDiv);
        }
    }

    function resetGame() {
        // Init logic board (0 = empty, 1 = p1, 2 = p2)
        board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
        currentPlayer = P1;
        gameOver = false;
        difficulty = parseInt(difficultySel.value);
        
        // Reset UI
        document.querySelectorAll('.slot').forEach(el => {
            el.className = 'slot empty';
        });
        updateStatus();
    }

    // --- Game Logic ---
    function handleMove(col) {
        if (gameOver || currentPlayer !== P1) return;

        if (isValidLocation(board, col)) {
            const row = getNextOpenRow(board, col);
            dropPiece(board, row, col, P1);
            updateUI(row, col, P1);

            if (checkWin(board, P1)) {
                endGame(P1);
                return;
            }
            if (isTie(board)) {
                endGame(0);
                return;
            }

            currentPlayer = P2;
            updateStatus();
            
            // AI Turn
            loaderEl.classList.add('active');
            // Small delay for UI update
            setTimeout(() => {
                makeAIMove();
                loaderEl.classList.remove('active');
            }, 100);
        }
    }

    function isValidLocation(b, col) {
        return b[ROWS - 1][col] === EMPTY;
    }

    function getNextOpenRow(b, col) {
        for (let r = 0; r < ROWS; r++) {
            if (b[r][col] === EMPTY) {
                return r;
            }
        }
        return -1;
    }

    function dropPiece(b, r, c, piece) {
        b[r][c] = piece;
    }

    function updateUI(r, c, player) {
        // ID is based on logic coordinates
        const slot = document.getElementById(`slot-${r}-${c}`);
        slot.classList.remove('empty');
        slot.classList.add(player === P1 ? 'p1' : 'p2');
    }

    function checkWin(b, piece) {
        // Check Horizontal
        for (let c = 0; c < COLS - 3; c++) {
            for (let r = 0; r < ROWS; r++) {
                if (b[r][c] == piece && b[r][c+1] == piece && b[r][c+2] == piece && b[r][c+3] == piece) return true;
            }
        }
        // Check Vertical
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS - 3; r++) {
                if (b[r][c] == piece && b[r+1][c] == piece && b[r+2][c] == piece && b[r+3][c] == piece) return true;
            }
        }
        // Check Diagonal /
        for (let c = 0; c < COLS - 3; c++) {
            for (let r = 0; r < ROWS - 3; r++) {
                if (b[r][c] == piece && b[r+1][c+1] == piece && b[r+2][c+2] == piece && b[r+3][c+3] == piece) return true;
            }
        }
        // Check Diagonal \
        for (let c = 0; c < COLS - 3; c++) {
            for (let r = 3; r < ROWS; r++) {
                if (b[r][c] == piece && b[r-1][c+1] == piece && b[r-2][c+2] == piece && b[r-3][c+3] == piece) return true;
            }
        }
        return false;
    }
    
    // Returns winning coordinates for highlighting
    function getWinningCoords(b, piece) {
        // Helper to check 4 spots
        const check = (r, c, dr, dc) => {
            return b[r][c] == piece && b[r+dr][c+dc] == piece && b[r+2*dr][c+2*dc] == piece && b[r+3*dr][c+3*dc] == piece;
        }

        // Horizontal
        for (let c = 0; c < COLS - 3; c++) {
            for (let r = 0; r < ROWS; r++) {
                if (check(r, c, 0, 1)) return [[r,c], [r,c+1], [r,c+2], [r,c+3]];
            }
        }
        // Vertical
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS - 3; r++) {
                if (check(r, c, 1, 0)) return [[r,c], [r+1,c], [r+2,c], [r+3,c]];
            }
        }
        // Diag /
        for (let c = 0; c < COLS - 3; c++) {
            for (let r = 0; r < ROWS - 3; r++) {
                if (check(r, c, 1, 1)) return [[r,c], [r+1,c+1], [r+2,c+2], [r+3,c+3]];
            }
        }
        // Diag \
        for (let c = 0; c < COLS - 3; c++) {
            for (let r = 3; r < ROWS; r++) {
                if (check(r, c, -1, 1)) return [[r,c], [r-1,c+1], [r-2,c+2], [r-3,c+3]];
            }
        }
        return [];
    }

    function isTie(b) {
        // If top row is full, board is full
        for (let c = 0; c < COLS; c++) {
            if (b[ROWS-1][c] === EMPTY) return false;
        }
        return true;
    }

    function updateStatus() {
        if (gameOver) return;
        if (currentPlayer === P1) {
            statusEl.innerText = "Your Turn (Red)";
            statusEl.style.color = "var(--p1-color)";
        } else {
            statusEl.innerText = "AI is thinking...";
            statusEl.style.color = "var(--p2-color)";
        }
    }

    function endGame(winner) {
        gameOver = true;
        if (winner === P1) {
            statusEl.innerText = "You Win!";
            highlightWin(P1);
        } else if (winner === P2) {
            statusEl.innerText = "AI Wins!";
            highlightWin(P2);
        } else {
            statusEl.innerText = "Draw!";
            statusEl.style.color = "#fff";
        }
    }

    function highlightWin(piece) {
        const coords = getWinningCoords(board, piece);
        coords.forEach(([r, c]) => {
            document.getElementById(`slot-${r}-${c}`).classList.add('win');
        });
    }

    // --- AI Implementation (Minimax) ---

    function makeAIMove() {
        let col, minimaxScore;

        // Easy Mode: Random
        if (difficulty === 1) {
            const validMoves = [];
            for(let c=0; c<COLS; c++) if(isValidLocation(board, c)) validMoves.push(c);
            col = validMoves[Math.floor(Math.random() * validMoves.length)];
        } 
        else {
            // Medium (Depth 3) & Hard (Depth 6)
            // Copy board for safety
            const boardCopy = board.map(row => [...row]);
            [col, minimaxScore] = minimax(boardCopy, difficulty, -Infinity, Infinity, true);
        }

        if (col !== null && col !== undefined) {
            const row = getNextOpenRow(board, col);
            dropPiece(board, row, col, P2);
            updateUI(row, col, P2);

            if (checkWin(board, P2)) {
                endGame(P2);
            } else if (isTie(board)) {
                endGame(0);
            } else {
                currentPlayer = P1;
                updateStatus();
            }
        }
    }

    function scorePosition(b, piece) {
        let score = 0;
        const oppPiece = piece === P1 ? P2 : P1;

        // Center column preference
        const centerArray = [];
        for(let r=0; r<ROWS; r++) centerArray.push(b[r][3]);
        const centerCount = centerArray.filter(x => x === piece).length;
        score += centerCount * 3;

        // Horizontal
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS - 3; c++) {
                const window = [b[r][c], b[r][c+1], b[r][c+2], b[r][c+3]];
                score += evaluateWindow(window, piece, oppPiece);
            }
        }

        // Vertical
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS - 3; r++) {
                const window = [b[r][c], b[r+1][c], b[r+2][c], b[r+3][c]];
                score += evaluateWindow(window, piece, oppPiece);
            }
        }

        // Diagonal /
        for (let r = 0; r < ROWS - 3; r++) {
            for (let c = 0; c < COLS - 3; c++) {
                const window = [b[r][c], b[r+1][c+1], b[r+2][c+2], b[r+3][c+3]];
                score += evaluateWindow(window, piece, oppPiece);
            }
        }

        // Diagonal \
        for (let r = 0; r < ROWS - 3; r++) {
            for (let c = 0; c < COLS - 3; c++) {
                const window = [b[r+3][c], b[r+2][c+1], b[r+1][c+2], b[r][c+3]];
                score += evaluateWindow(window, piece, oppPiece);
            }
        }

        return score;
    }

    function evaluateWindow(window, piece, oppPiece) {
        let score = 0;
        const countPiece = window.filter(x => x === piece).length;
        const countEmpty = window.filter(x => x === EMPTY).length;
        const countOpp = window.filter(x => x === oppPiece).length;

        if (countPiece === 4) return 100;
        if (countPiece === 3 && countEmpty === 1) score += 5;
        if (countPiece === 2 && countEmpty === 2) score += 2;

        if (countOpp === 3 && countEmpty === 1) score -= 4;

        return score;
    }

    function minimax(b, depth, alpha, beta, maximizingPlayer) {
        const validLocations = [];
        for(let c=0; c<COLS; c++) if(isValidLocation(b, c)) validLocations.push(c);

        const isTerminal = checkWin(b, P1) || checkWin(b, P2) || validLocations.length === 0;

        if (depth === 0 || isTerminal) {
            if (isTerminal) {
                if (checkWin(b, P2)) return [null, 1000000000];
                if (checkWin(b, P1)) return [null, -1000000000];
                return [null, 0];
            } else {
                return [null, scorePosition(b, P2)];
            }
        }

        if (maximizingPlayer) {
            let value = -Infinity;
            let column = validLocations[Math.floor(Math.random() * validLocations.length)];
            
            // Sort center outward for better pruning
            validLocations.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));

            for (let col of validLocations) {
                const row = getNextOpenRow(b, col);
                const bCopy = b.map(r => [...r]);
                dropPiece(bCopy, row, col, P2);
                const newScore = minimax(bCopy, depth - 1, alpha, beta, false)[1];
                if (newScore > value) {
                    value = newScore;
                    column = col;
                }
                alpha = Math.max(alpha, value);
                if (alpha >= beta) break;
            }
            return [column, value];
        } else {
            let value = Infinity;
            let column = validLocations[Math.floor(Math.random() * validLocations.length)];
            
            validLocations.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));

            for (let col of validLocations) {
                const row = getNextOpenRow(b, col);
                const bCopy = b.map(r => [...r]);
                dropPiece(bCopy, row, col, P1);
                const newScore = minimax(bCopy, depth - 1, alpha, beta, true)[1];
                if (newScore < value) {
                    value = newScore;
                    column = col;
                }
                beta = Math.min(beta, value);
                if (alpha >= beta) break;
            }
            return [column, value];
        }
    }

    // Start
    init();

</script>
</body>
</html>
